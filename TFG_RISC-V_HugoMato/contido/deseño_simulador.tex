\chapter{Deseño do simulador}
\label{chap:deseño_simulador}

\lettrine{D}{erradeiro} 
\section{RTL}\label{sec:rtl}
Esta é 
O simulador funciona a \acrfull{rtl}, polo que se poden ver como se actualizan os datos no rexistros. Ademais, 

%https://www.guiahardware.es/rtl/
%https://en.wikipedia.org/wiki/Register-transfer_level

\section{Pipeline de 5 etapas}\label{sec:pipeline_5etapas}
A división do pipeline comeza co nacemento dos primeiros ordenadores superescalares en REFES AQUI. A idea é aumentar o rendemento ao permitir que o procesador execute máis dunha instrución por ciclo. Para iso, divídese a execución en 5 etapas, habitualmente Fetch, Decode, Execute, Memory e Write Back.


En Fetch obténse a instrución de memoria. Durante Decode procésase a instrución obtida, analizando que tipo de operación se realizará, cales son os rexistros empregados, se hai algunha dependencia, etc. En Execute realízase a operación determinada, como pode ser un cálculo na \acrfull{alu}. En Memory, se é necesario, escríbese ou léese en memoria. Finalmente, en Write Back actualízanse os rexistros.


O procesador RISC-V emprega un pipeline deste tipo, polo que ao deseñar o simulador hai que ter en conta as 5 etapas. A aproximación realizada foi dividir cada etapa en un módulo do simulador, salvando Decod e Write Back que se uniron por comodidade.

\section{Módulos do simulador}\label{sec:modulso_sim}
Os módulos principais, como se comentou no apartado anterior, son cada unha das 5 etapas, fusionando Decod e Write Back. No caso da etapa Execute, simplemente se creou unha \acrshort{alu}, encargada de realizar operacións de suma, resta e outras operacións lóxicas. Ademais, engadíronse varios módulos ao longo do proxecto. Para as operacións de multiplicación e división da extensión M, creouse un novo módulo. Separar estas funcionalidades permite organizar o traballo, ademais de simplificalo e facerlo máis sinxelo de depurar. Para a extensión F, de forma análoga, existe un compoñente encargado de realizar todas as operacións de punto flotante simple.

\section{Modos de operación}\label{sec:modos_op}
Coa fin de mellorar a calidade da simulación, decidíuse engadir no módulo de multiplicación a posibilidade de elixir entre dous modos de funcionamento. O primeiro limita de forma que,, se hai unha multiplicación executándose, non se pode realizar ningunha outra operación no módulo. Isto pretende semellarse a un caso real, no que, por limitacións físicas, se empregan os mesmos circuítos para ambas operacións. O segundo modo, permite que se executen todas as multiplicacións necesarias pero solo unha división ao mesmo tempo.


\section{Simulación de latencias}\label{sec:sim_latencias}
Á hora de executar código, existen varios axustes que se poden cambiar para simular distintos comportamentos típicos de RISC-V. Pódese modificar a latencia  das operacións do módulo de multiplicación, as cales son: 
\begin{itemize}
    \item MUL
    \item MULH
    \item MULHU
    \item MULHSU
    \item DIV
    \item DIVU
    \item REM
    \item REMU
\end{itemize}
Isto permite unha representación máis realista, xa que por defecto todas as instrucións no simulador teñen unha latencia dun ciclo. Sen embargo, na realidade, operacións máis complexas como as multiplicacións ou división levan varios ciclos.

\section{Sinais de hazard}\label{sec:hazards}
Como en sucede en moitas \gls{arquitecturas}, a execución de instrucións moitas veces vese limitada por dependencias. Isto é, non se pode continuar co programa porque a seguinte instrución emprega algún rexistro que debe ser actualizado previamente, pero non esto aínda non sucedeu porque algunha instrución previa non acabou a súa execución. Para evitar esta situación, en moitos casos engádense burbullas, o que son ciclos nos que non se fai ningún traballo. O simulador replica este funcionamento, polo que para detectar estas dependencias emprega sinais de \gls{hazards}.

Chámase hazard a calquera perigo que poidese causar un risco \acrfull{raw}, \acrfull{war} ou \acrfull{waw}. Polo que para evitar un hazard, débese detectar unha dependencia con suficiente antelación. A nosa elixida neste caso foron empregar sinais nos módulos de punto-flotante, multiplicación e \acrshort{alu} conectados co módulo de decodificación. Se foi detectado unha dependencia, o sinal enviará un alertará ao módulo e este creará burbullas ata que non exista a dependencia.