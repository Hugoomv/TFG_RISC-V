\chapter{Modelado e simulación}
\label{chap:mod_sim}

\lettrine{N}{este} apartado explicaránse os fundamentos dun simulador, os motivos para crear un e o funcionamento típico. Ademais, indicaránse as linguaxes máis habituais destes casos, as diferenzas e o motivo da elección de SystemC. 

\section{Por que é importante o modelado e a simulación?}\label{sec:mod_sim}
Durante o proceso de creación de calquera compoñente electrónico minimamente complexo, é necesario revisar que o deseño realiza as funcións esperadas e de forma correcta. Isto é, que garante os resultados esperados, dentro dun tempo razoable e cun emprego de recursos limitado. Unha opción é encargar un novo chip cada vez que se crea un deseño que se necesita revisar. Se ben é posible, os longos períodos de tempo de creación e os altos custos son un impedimento enorme. No seu lugar, créase unha versión dixital mediante \gls{software}. Este é o modelado, mentres que se queremos que o deseño imite o comportamento real para poder ver os erros, é necesario un simulador. En moitos casos, estas ferramentas están xuntas, facendo máis sinxelo o traballo.
Grazas á existencia destes programas, o deseño e creación de compoñentes electrónicos é moito máis veloz e barato, permitindo un avance tecnolóxico con menos limitacións.


\section{VHDL e Verilog}\label{sec:vhdl_verilog}
Estas linguaxes son empregadas principalmente para describir circuítos de forma moi precisa, permitindo incluso diferenciar unha simple conexión dun rexistro. Ademais, os compiladores para \acrfull{hdl} son capaces de xerar circuítos de alta calidade, imposibles de realizar para un ser humano. Á hora de modelar e simular, son as máis empregadas. Coñecidas por ser o estándar na industria, permiten traballar a baixo nivel. Isto garante unha gran eficiencia e rendemento, ademais de ofrecer flexibilidade. Da mesma forma que a cercanía ao hardware ofrece algunhas melloras, tamén ten desvantaxes, como a maior complexidade á hora de escribir código, falta de características típicas de \acrfull{oop}, \dots

\section{SystemC}\label{sec:systemc}
SystemC foi creada en C++ e é habitualmente empregada para codeseño. O feito de que sexa de alto nivel proporciona unha flexibilidade e sinxeleza á hora de traballar que carecen as alternativas máis próximas ao \gls{hardware}. Engade a posibilidade de ter datos públicos e privados, permite organizar todo en clases facilitando un deseño modular, xestionar eventos e modelar a varios niveis, como \acrfull{rtl} ou \acrfull{tlm}.
Para o modelado e a simulación, a escolla habitual, como se comentaba na sección anterior (\ref{sec:vhdl_verilog}), é \acrshort{vhdl} ou Verilog. Sen embargo, a elección de SystemC antes que \acrfull{vhdl} ou Verilog foi debido a que permite traballar a un nivel máis alto, a simulación é moito máis rápida e, ademais, a base do proxecto inicial sobre o que se traballou xa estaba feita empregando esta \gls{meta-linguaxe}.


SystemC é unha meta-linguaxe creada en C++, empregada principalmente para codeseño. Permite traballar en \acrshort{rtl} e \acrshort{tlm},  con dataflow, engadir código en C/C++, \dots  Ademais, implementa funcionalidades similares ás de \acrshort{vhdl} e Verilog, pero proporcionando unha maior velocidade de simulación. Tamén destacar que o feito de que empregue C++ ofrece a posibilidade de organizar o proxecto en clases e módulos, imprimir variables ou ler arquivos. Isto sería moito máis complexo noutras linguaxes de baixo nivel, xa que non ofrecen funcións de alto nivel nin tanta flexibilidade. Por último destacar características varias como: \begin{itemize}
    \item Inicialización automática de datos internos
    \item Funcionalidades de linguaxes orientados a obxectos
    \item Xestión de eventos
    \item Datos públicos e privados
    \item Tipos de datos xa definidos (máis sinxelos para traballar con eles)
    \item Precisión de ciclo de reloxo
    \item Permite implementacións con lóxica combinacional e secuencial
\end{itemize} 


\section{Spike}\label{sec:spike}
A propia organización de RISC-V xa ofrece un simulador ~\cite{sim_spike}, pero seguen existindo motivos para crear unha alternativa. Non simula cada ciclo, senón que é un \acrfull{iss}. Spike é parametrizable, xa que permite cambiar o número de ciclos, núcleos, modificar a memoria, que extensións emprega, \dots. Está escrito en C/C++ polo que ofrece unha boa velocidade de simulación. Ademais, trátase dun proxecto open-source, polo que calquera pode colaborar e  avanza de forma constante. Funciona coa base RV32I, RV64I, RV32E, RV64E. Tamén a gran maioría de extensións na versión v1.0, e nas últimas versións as extensións M (multiplicación/división), A (atómicas), F/D (punto flotante simple/dobre precisión), C (instrucións comprimidas) e V (vectorial). Inclúe soporte para debug, simula diferentes niveis de privilexio e ofrece compatibilidade con binarios .elf. 

Se ben é un bo simulador cunha ampla oferta de características, este proxecto busca ofrecer unha alternativa que mostre o funcionamento dun programa de forma máis precisa e orientado a unha posterior implementación do deseño. Spike simula a nivel de instrución, polo que non se poden ver como cambian os valores dos rexistros con cada ciclo, hazards, pipelines ou sinais de comunicación entre módulos.

