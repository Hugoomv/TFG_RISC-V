\chapter{Modelado e simulación}
\label{chap:mod_sim}

\lettrine{N}{este} apartado explicaránse os fundamentos dun simulador, os motivos para crear un e o funcionamento típico. Ademais, indicaránse as linguaxes máis habituais destes casos, as diferenzas e o motivo da elección de SystemC. 

\section{Por que é importante o modelado e a simulación?}\label{sec:mod_sim}
Durante o proceso de creación de calquera compoñente electrónico minimamente complexo, é necesario revisar que o deseño realiza as funcións esperadas e de forma correcta. Isto é, que garante os resultados esperados, dentro dun tempo razoable e cun emprego de recursos limitado. Unha opción é encargar un novo chip cada vez que se crea un deseño que se necesita revisar. Se ben é posible, os longos períodos de tempo de creación e os altos custos son un impedimento enorme. No seu lugar, créase unha versión dixital mediante \gls{software}. Este é o modelado, mentres que se queremos que o deseño imite o comportamento real para poder ver os erros, é necesario un simulador. En moitos casos, estas ferramentas están xuntas, facendo máis sinxelo o traballo.
Grazas á existencia destes programas, o deseño e creación de compoñentes electrónicos é moito máis veloz e barato, permitindo un avance tecnolóxico con menos limitacións.


\section{VHDL e Verilog}\label{sec:vhdl_verilog}
Estas linguaxes son empregadas principalmente para describir circuítos de forma moi precisa, permitindo incluso diferenciar que é unha simple conexión dun rexistro. Ademais, os compiladores para \acrfull{hdl} son capaces de xerar circuítos de alta calidade, imposibles de realizar para un ser humano. Á hora de modelar e simular, son as máis empregadas. Coñecidas por ser o estándar na industria, permiten traballar a baixo nivel. Isto garante unha gran eficiencia e rendemento, ademais de ofrecer flexibilidade. Da mesma forma que a cercanía ao hardware ofrece algunhas melloras, tamén ten desvantaxes, como a maior complexidade á hora de escribir código, falta de características típicas de \acrfull{oop}, \dots

A elección de SystemC antes que VHDL ou Verilog foi debido a que permite traballar a un nivel máis alto, a simulación é moito máis rápida e ademais, a base do proxecto inicial sobre o que se traballou xa estaba feita empregando esta libraría.

\section{SystemC}\label{sec:systemc}
Para o modelado e a simulación, a escolla habitual, como se comentaba na sección anterior (\ref{sec:vhdl_verilog}), é VHDL ou Verilog. Sen embargo, para este proxecto elixiuse SystemC. Esta \gls{meta-linguaxe} creada en C++, é habitualmente empregada para codeseño. O feito de que sexa unha linguaxe de alto nivel, proporciona unha flexibilidade e sinxeleza á hora de traballar que carecen as linguaxes de máis baixo nivel. Engade a posibilidade de ter datos públicos e privados, permite organizar todo en clases, facilitando un deseño modular, gestionar eventos e modelar a varios niveis, como \acrfull{rtl} ou \acrfull{tlm}. Ademais, destacar que é moito máis rápido para a simulación que VHDL ou Verilog.

\section{Spike}\label{sec:spike}
A propia organización de RISC-V xa ofrece un simulador ~\cite{sim_spike}, pero seguen existindo motivos para crear unha alternativa. Non simula cada ciclo, senón que funciona a \acrfull{iss}. Spike é parametrizable, xa que permite cambiar o número de ciclos, núcleos, modificar a memoria, que extensións emprega, \dots. Está escrito en C/C++ polo que ofrece unha boa velocidade de simulación. Ademais, trátase dun proxecto open-source, polo que calquera pode colaborar e  avanza de forma constante. Funciona coa base RV32I, RV64I, RV32E, RV64E. Tamén a gran maioría de extensións na versión v1.0, e nas últimas versións as extensións I (entero base), M (multiplicación/división), A (atómicas), F/D (punto flotante simple/dobre precisión), C (instrucións comprimidas), V (vectorial). Inclúe soporte para debug, simula diferentes niveis de privilexio e compatibilidade con binarios .elf. 

Se ben é un bo simulador cunha ampla oferta de características, este proxecto busca ofrecer unha alternativa que mostre o funcionamento dun programa de forma máis precisa. Spike simula a nivel de instrución, polo que non se poden ver como cambian os valores dos rexistros con cada ciclo, hazards, pipelines ou sinais de comunicación entre módulos.

