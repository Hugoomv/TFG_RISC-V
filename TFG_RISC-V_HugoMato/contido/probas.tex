\chapter{Probas}
\label{chap:probas}

\lettrine{U}{nha} parte imprescindible de calquera proxecto é o período de probas ou testing, durante o cal se busca atopar bugs e comprobar que o funcionamento é o esperado e é correcto. Ao longo deste capítulo explicaránse os distintos exames aos que se someteu o simulador, o seu obxectivo, orixe e diferenzas fundamentais.

\section{Benchmarks}\label{sec:benchmarks}
Unha vez implementada unha nova instrución, ou un pipeline, é necesario comprobar que o funcionamento é o esperado. Para iso, empréganse diferentes métodos. Un deles son os benchmarks, diferentes probas que buscan crear casos habituais e incluso os máis extremos ou menos frecuentes. A fonte destes benchmarks é o repositorio de RISC-V ~\cite{riscv_tests}. Aquí existen diferentes programas orientados a probar determinadas funcións, como a multiplicación con SPMV. Os benchmarks empregados durante o traballo son os seguintes:
\begin{table}[hp!]
  \centering
  \rowcolors{2}{white}{udcgray!25}
  \begin{tabular}{|p{5cm}|p{8cm}|}
    \rowcolor{udcpink!25}
    \textbf{Nome do benchmark} & \textbf{Obxectivo} \\\hline
    \textit{SPMV} & Multiplicacións \\
    \textit{Median} & Suma, comparacións e desplazamentos de datos \\
    \textit{Multiply} & Suma, resta, comparacións e desplazamentos de datos \\
    \textit{Qsort} & Suma e comparacións con operando inmediato e desplazamentos de datos \\
    \textit{Rsort} & Suma e comparacións con operando inmediato e desplazamentos de datos \\
    \textit{Vvadd} & Suma de vectores\\
  \end{tabular}
  \caption{Benchmarks empregados e con que fin.}
  \label{tab:benchmarks}
\end{table}

\section{Tests propios}\label{sec:tests}
Ademais de empregar os benchmarks, foron creados varios exames buscando probar especificamente certas funcionalidades segundo fose necesario. O concepto básico foi imitar algún benchmark de instrución atopado no repositorio oficial ~\cite{riscv_tests}. Como se ve no apéndice \ref{cod_test} , consiste en empregar código ensamblador embebido ~\cite{asm_emb} para integrar a instrución no código en C. Ademais, compróbase o resultado da operación gardando o que devolve e comparando co resultado esperado. Na súa maioría son bastante sinxelos; sen embargo, tendo en conta determinados casos que poderían ser problemáticos, serven para determinar se unha instrución está ben implementada.


\section{Depuración}\label{sec:depuración}
Chámase depuración ao proceso de revisión exhaustiva do software en busca de erros. Calquera programa durante o proceso de desenvolvemento sofre varias revisións, tipicamente empregando o \acrshort{ide}. Este permite deterse en determinada instrución, imprimir o valor dunha variable antes e despois dun cambio, etc. Para este punto, tanto Segger como Visual Studio foron moi útiles, xa que proporcionan ferramentas perfectamente integradas. Neste proxecto, tamén foi moi útil GTK Wave (ver \ref{sec:gtkwave}) para poder visualizar as trazas dos sinais máis relevantes, para así ver como varían ciclo a ciclo e poder comparar de forma visual e sinxela.

\section{Resultados}\label{chap:resultados}
Tras finalizar o proxecto, pódese garantir que engadir novas extensións coas súas correspondentes novas instrucións non compromete o traballo anterior. O funcionamento do resto de módulos segue sendo correcto e o rendemento non se viu deteriorado en ningún momento.

Por outra parte, a posibilidade de modificar as latencias dalgunhas instrucións grazas á parametrización engadida, mostra como cambia o rendemento no conxunto dun programa. Por exemplo, á hora de executar o benchmark SPMV que realiza multiplicación de enteiros, obtemos resultados moi interesantes segundo as latencias. Como vemos na táboa \ref{tab:rendemento_spmv}, o número de instrucións non varía, o que é lóxico xa que só se modifica a súa latencia. Un cambio na cantidade de operacións realizadas implicaría engadir novas instrucións dependendo da latencia de determinadas instrucións. Se ben se emiten instrucións \acrshort{nop} cando se detectan hazards, estas fan a función de burbullas, non se fai nada salvo pasar ao seguinte ciclo. Sen embargo, o tempo, isto é, o número de ciclos necesarios para executar o programa aumenta notablemente. Comparando o aumento de ciclos para a mesma latencia en mul e mulhu, dedúcese que se executan máis instrucións mul. O cal é razoable, xa que revisando o binario, vese que é correcto. Ademais, o test realiza multiplicacións de enteiros, e a operación mul é imprescindible para isto, mentres que mulhu encárgase da parte superior da multiplicación, innecesaria cando se empregan números pequenos.

\begin{table}[hp!]
    \centering
    \rowcolors{2}{white}{udcgray!25}
    \begin{tabular}{c|c|c}
    \rowcolor{udcpink!25}
    \textbf{Modificacións realizadas} & \textbf{Número de instrucións}  & \textbf{Tempo} 
    \\\hline
    \textit{SPMV base} & 399515 & 955924 \\
    \textit{Latencia de mul = 5} & 399515 & 984652\\
    \textit{Latencia de mul = 10} & 399515 & 1020562\\
     \textit{Latencia de mulhu = 5} & 399515 & 965500\\ 
    \textit{Latencia de mulhu = 10} & 399515 & 940504\\ % REV ERROR
    \textit{Latencia de mul = 5 e mulhu = 5} & 399515 & 984652\\
    \end{tabular}
    \caption{Rendemento do benchmarks SPMV segundo as latencia de distintas operacións.}
    \label{tab:rendemento_spmv}
\end{table}

Finalmente, destacar que a velocidade de simulación deste proxecto en comparación coa que se podería obter se \acrshort{vhdl} ou Verilog fose empregado é moi superior. Por exemplo, o benchmark SPMV execútase en apenas 30 segundos.

